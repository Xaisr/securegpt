// Content script for Anonymizer Extension

// Pre-defined selectors for specific websites
const websiteSelectors = {
    'www.google.com': 'textarea[name="q"]',
    'chat.openai.com': '#prompt-textarea',  // For ChatGPT's contenteditable div
    'chatgpt.com': '#prompt-textarea'       // In case the hostname is different
};

let anonymizerEnabled = true;
let toggleButton = null;

// Create and add the toggle button
function createToggleButton() {
    if (toggleButton && document.body.contains(toggleButton)) return;

    toggleButton = document.createElement('button');
    toggleButton.innerText = 'Anonymizer';
    toggleButton.style.position = 'fixed';
    toggleButton.style.top = '10px';
    toggleButton.style.right = '10px';
    toggleButton.style.zIndex = '10000000';
    toggleButton.style.backgroundColor = 'green';
    toggleButton.style.color = 'white';
    toggleButton.style.border = 'none';
    toggleButton.style.padding = '10px';
    toggleButton.style.cursor = 'pointer';
    toggleButton.style.fontFamily = 'Arial, sans-serif';
    toggleButton.style.fontSize = '14px';
    toggleButton.style.borderRadius = '5px';

    toggleButton.addEventListener('click', () => {
        anonymizerEnabled = !anonymizerEnabled;
        toggleButton.style.backgroundColor = anonymizerEnabled ? 'green' : 'red';
    });

    document.body.appendChild(toggleButton);
}

// Function to highlight potentially anonymizable text
function highlightAnonymizableText(inputElement) {
    if (!anonymizerEnabled) return;

    // Get the text based on the input type (textarea or contenteditable div)
    let text = inputElement.value || inputElement.innerText || inputElement.textContent;

    fetch('http://127.0.0.1:5000/analyze', {  // Local server assumed
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify({ text: text }),
    })
    .then(response => response.json())
    .then(data => {
        if (data.entities && data.entities.length > 0) {
            let highlightedText = text;

            // Highlight each entity
            data.entities.forEach(entity => {
                const regex = new RegExp(entity.text, 'g');
                highlightedText = highlightedText.replace(regex, `**${entity.text}**`);  // Bold sensitive words
            });

            // Update the text inside the search field (depending on the type of input)
            if (inputElement.tagName.toLowerCase() === 'textarea') {
                inputElement.value = highlightedText;  // Update value in textarea
            } else if (inputElement.contentEditable === "true") {
                inputElement.innerHTML = highlightedText;  // Update innerHTML in contenteditable div
            }
        }
    })
    .catch(error => {
        console.error("Error analyzing text:", error);
    });
}

// Function to handle Tab key press
function handleTabPress(event) {
    if (event.key === 'Tab' && anonymizerEnabled) {
        const hostname = window.location.hostname;
        if (hostname in websiteSelectors) {
            const searchInput = document.querySelector(websiteSelectors[hostname]);
            if (searchInput) {
                event.preventDefault();  // Prevent the default Tab action
                highlightAnonymizableText(searchInput);  // Highlight anonymizable text
            }
        }
    }
}

// Main function to initialize the extension
function initializeAnonymizer() {
    createToggleButton();

    // Add event listener for keydown events to detect 'Tab' key press
    document.addEventListener('keydown', handleTabPress);

    // Observe DOM changes for dynamically loaded search inputs
    const observer = new MutationObserver((mutations) => {
        mutations.forEach((mutation) => {
            if (mutation.type === 'childList') {
                const hostname = window.location.hostname;
                if (hostname in websiteSelectors) {
                    const searchInput = document.querySelector(websiteSelectors[hostname]);
                    if (searchInput && !searchInput.dataset.anonymizerInitialized) {
                        searchInput.dataset.anonymizerInitialized = 'true';
                        searchInput.addEventListener('keydown', handleTabPress);
                    }
                }
            }
        });

        // Ensure the toggle button is always present
        createToggleButton();
    });

    observer.observe(document.body, { childList: true, subtree: true });
}

// Initialize the anonymizer when the content script loads
initializeAnonymizer();

// Re-run initialization after a short delay to handle late-loading pages
setTimeout(initializeAnonymizer, 1000);

// Continuously check if the toggle button is removed and re-add if necessary
setInterval(createToggleButton, 1000);
